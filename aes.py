# Reference:
# https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf

# The block ciphers AES-128, AES-192 and AES-256 differ in 3 aspects
# 1) Length of key
# 2) Number of rounds -> determines the size of required key schedule
# 3) Specification of recursion in KeyExpansion()
#
# Number of rounds is denoted by nr and the number of words of the key
# is denoted by nk
#
# AES-128 -> nk = 4, nr = 10
# AES-192 -> nk = 6, nr = 12
# AES-256 -> nk = 8, nr = 14

# fmt: off
# Let 'b' denote an input byte to SBox(), and let 'c' denote the constant
# byte 01100011. The output byte b' = SBox(b) is constructed by 2
# transformations:
# 1) An intermediate value b˜
#    b˜ = { {00} if b = {00} else b^−1 }
#    Where b^-1 is the multiplicative inverse of b in GF(2^8)
#
# 2) Apply affine transformation to the bits of b˜ to produce b'
#    bi' = bi˜⊕ b˜(i + 4) mod 8 ⊕ b˜(i + 5) mod 8 ⊕ b˜(i + 6) mod 8 ⊕ b˜(i + 7) mod 8 ⊕ ci
s_box = (
    (0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76),
    (0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0),
    (0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15),
    (0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75),
    (0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84),
    (0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF),
    (0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8),
    (0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2),
    (0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73),
    (0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB),
    (0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79),
    (0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08),
    (0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A),
    (0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E),
    (0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF),
    (0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16),
)

inv_s_box = (
    (0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB),
    (0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB),
    (0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E),
    (0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25),
    (0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92),
    (0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84),
    (0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06),
    (0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B),
    (0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73),
    (0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E),
    (0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B),
    (0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4),
    (0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F),
    (0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF),
    (0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61),
    (0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D),
)
# fmt: on

r_con = (0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36)


def sub_word(word: list[int]) -> list[int]:
    return [s_box[byte >> 4][byte & 0xF] for byte in word]


# KeyExpansion() is a routine that is applied to the key to generateround
# 4 * (rounds + 1) words. 4 words are generated for each (round + 1) applications
# of AddRoundKey() in Cipher(). The output consists of a linear array of words,
# denoted by w[i] where 0 <= i < 4 * (rounds + 1)
#
# It invokes 10 fixed words denoted by Rcon[j] for 1 <= j <= 10, known as round
# constants. For AES-128, a distinct round constant is called in generation of
# each of the 10 round keys.
#
# 2 transformations on words are called
# 1) RotWord([a0, a1, a2, a3]) = [a1, a2, a3, a0]
# 2) SubWord([a0, a1, a2, a3]) = [SBox(a0), SBox(a1), SBox(s2), SBox(a3)]
def key_expansion(key: list[int], nk: int, nr: int) -> list[list[int]]:
    # Each word is of 4 bytes, output is of size 4 * (nr + 1)
    w = [[0 for _ in range(4)] for _ in range(4 * (nr + 1))]
    for i in range(nk):
        w[i] = key[4 * i : 4 * (i + 1)]

    for i in range(nk, 4 * (nr + 1)):
        temp = w[i - 1].copy()
        if i % nk == 0:
            temp = sub_word(temp[1:] + temp[:1])
            temp[0] ^= r_con[i // nk - 1]
        elif nk > 6 and i % nk == 4:
            temp = sub_word(temp)
        for j in range(4):
            w[i][j] = w[i - nk][j] ^ temp[j]
    return w


# AddRoundKey() is a transformation of the state in which a round key is
# combined with the state by applying XOR operation.
#
# [s'[0,c], s'[1,c], s'[2,c], s'[3,c]] = [s[0, c], s[1, c], s[2, c], s[3, c]] ⊕ w[4 * round + c]
def add_round_key(
    state: list[list[int]], round_key: list[list[int]]
) -> list[list[int]]:
    for r in range(4):
        for c in range(4):
            # Round key is stored row-wise and has to be used
            # column-wise, so it is indexed using round_key[c][r]
            state[r][c] ^= round_key[c][r]
    return state


# SubBytes() is an invertible, non-linear transformation of the state in
# which a S-box is applied independently to each byte in the state.
def sub_bytes(state: list[list[int]]) -> list[list[int]]:
    for r in range(4):
        for c in range(4):
            b = state[r][c]
            state[r][c] = s_box[b >> 4][b & 0xF]
    return state


# ShiftRows() is a transformation of the state in which the bytes in the
# last 3 rows of the state are cyclically shifted. The number of positions
# by which the bytes are shifted depends on the row index r.
#
# s'[r, c] = s[r, (c + r) mod 4]
# for 0 <= r < 4 and 0 <= c < 4
def shift_rows(state: list[list[int]]) -> list[list[int]]:
    for r in range(1, 4):
        state[r] = state[r][r:] + state[r][:r]
    return state


# Multiplication in GF(2^8) is defined on 2 bytes in two steps:
# 1) 2 polynomials that represent the bytes are multiplied as polynomials
# 2) Resulting polynomial is reduced module the following fixed polynomial
#    m(x) = x^8 + x^4 + x^3 + x + 1
#
# Product b•2 can be expressed as:
# x_times(b) = { b6b5b4b3b2b10 if b7 == 0
#                b6b5b4b3b2b10 ⊕ 00011011 if b7 = 1}
def gf_mul(m: int, n: int) -> int:
    result = 0
    for _ in range(8):
        if n & 1:
            result ^= m
        carry = m & 0x80
        m <<= 1
        if carry:
            # Irreducible polynomial
            m ^= 0x1B
        n >>= 1
    return result & 0xFF


# MixColumns() is a transformation of the state that multiplies each of the
# 4 columns of the state by a single fixed matrix
#
# [a0, a1, a2, a3] = [{02}, {01}, {01}, {03}]
def mix_columns(state: list[list[int]]) -> list[list[int]]:
    matrix = (
        (0x02, 0x03, 0x01, 0x01),
        (0x01, 0x02, 0x03, 0x01),
        (0x01, 0x01, 0x02, 0x03),
        (0x03, 0x01, 0x01, 0x02),
    )
    for c in range(4):
        cols = [state[r][c] for r in range(4)]
        for r in range(4):
            result = 0
            for col, a in zip(cols, matrix[r]):
                result ^= gf_mul(col, a)
            state[r][c] = result
    return state


# Arguments for Cipher are:
# 1) Data input 'in' -> block represented as linear array of 16 bytes
# 2) Number of rounds for the instance
# 3) The round keys
#
# AES-128(in, key) = Cipher(in, 10, KeyExpansion(key))
# AES-192(in, key) = Cipher(in, 12, KeyExpansion(key))
# AES-256(in, key) = Cipher(in, 14, KeyExpansion(key))
def cipher(input: list[int], nr: int, w: list[list[int]]):
    # Internally, the algorithms for AES block ciphers are performed on a
    # 2D array of bytes called state.
    #
    # s[r, c] = in[r + 4c]
    # out[r + 4c] = s[r, c]
    state = [[input[r + 4 * c] for c in range(4)] for r in range(4)]
    state = add_round_key(state, w[0:4])
    for round in range(1, nr):
        state = sub_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, w[4 * round : 4 * (round + 1)])
    state = sub_bytes(state)
    state = shift_rows(state)
    state = add_round_key(state, w[4 * nr : 4 * (nr + 1)])
    return state


def inv_shift_rows(state: list[list[int]]) -> list[list[int]]:
    for r in range(1, 4):
        state[r] = state[r][-r:] + state[r][:-r]
    return state


def inv_sub_bytes(state: list[list[int]]) -> list[list[int]]:
    for r in range(4):
        for c in range(4):
            b = state[r][c]
            state[r][c] = inv_s_box[b >> 4][b & 0xF]
    return state


def inv_mix_columns(state: list[list[int]]) -> list[list[int]]:
    matrix = (
        (0x0E, 0x0B, 0x0D, 0x09),
        (0x09, 0x0E, 0x0B, 0x0D),
        (0x0D, 0x09, 0x0E, 0x0B),
        (0x0B, 0x0D, 0x09, 0x0E),
    )
    for c in range(4):
        cols = [state[r][c] for r in range(4)]
        for r in range(4):
            result = 0
            for col, a in zip(cols, matrix[r]):
                result ^= gf_mul(col, a)
            state[r][c] = result
    return state


def inv_cipher(input: list[int], nr: int, w: list[list[int]]):
    state = [[input[r + 4 * c] for c in range(4)] for r in range(4)]
    state = add_round_key(state, w[4 * nr : 4 * (nr + 1)])
    for round in range(nr - 1, 0, -1):
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
        state = add_round_key(state, w[4 * round : 4 * (round + 1)])
        state = inv_mix_columns(state)
    state = inv_shift_rows(state)
    state = inv_sub_bytes(state)
    state = add_round_key(state, w[0:4])
    return state


# fmt: off
key = [
    0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
]
input = [
    0x32, 0x43, 0xF6, 0xA8, 0x88, 0x5A, 0x30, 0x8D, 0x31, 0x31, 0x98, 0xA2, 0xE0, 0x37, 0x07, 0x34
]
# fmt: on
got = cipher(input, 10, key_expansion(key, 4, 10))
want = [
    [0x39, 0x02, 0xDC, 0x19],
    [0x25, 0xDC, 0x11, 0x6A],
    [0x84, 0x09, 0x85, 0x0B],
    [0x1D, 0xFB, 0x97, 0x32],
]
assert got == want

output = [0 for _ in range(16)]
for r in range(4):
    for c in range(4):
        output[r + 4 * c] = want[r][c]

decrypted = inv_cipher(output, 10, key_expansion(key, 4, 10))

got = [0 for _ in range(16)]
for r in range(4):
    for c in range(4):
        got[r + 4 * c] = decrypted[r][c]

assert input == got
